<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Random Spinning Wheel</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
  <!-- Load Tailwind CSS for styling the UI -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>

<body class="p-4 md:p-8 flex justify-center items-center">
 <div class="navbar">
    <div class="logo">Random Student App</div>
    <div class="nav-links">
  <a href="{{ url_for('home') }}">Spinner</a>
  <a href="{{ url_for('group_page') }}">Group</a>
  <a href="{{ url_for('images_page') }}">Image</a>
    </div>
  </div>
  <main class="grid grid-cols-1 lg:grid-cols-3 gap-6 max-w-7xl w-full">

    <!-- 1. INPUTS and Controls Section -->
    <div class="card p-4 flex flex-col order-3 lg:order-1 col-span-1 lg:col-span-1">
      <h2 class="text-xl font-bold mb-4 border-b pb-2 text-gray-800">1. Entries & Controls</h2>

      <!-- Add Entry Input -->
      <div class="flex mb-4">
        <input type="text" id="newEntryName" placeholder="Input name/option..."
          class="flex-grow p-3 border border-gray-300 rounded-l-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-sm"
          aria-label="New entry name input">
        <button id="addEntryBtn"
          class="bg-blue-600 text-white p-3 rounded-r-lg hover:bg-blue-700 transition duration-150 active:bg-blue-800 font-bold"
          aria-label="Add entry">ADD</button>
      </div>

      <!-- Entry List -->
      <div id="entryList" class="flex-grow overflow-y-auto space-y-2 max-h-96 border p-2 rounded-lg bg-gray-50 mb-4">
        <!-- Entry items will be injected here -->
      </div>

      <div class="mt-auto pt-4 border-t space-y-3">
        <button id="spinWheelBtn"
          class="w-full bg-yellow-400 text-gray-800 font-bold p-3 rounded-xl shadow-md hover:shadow-lg transition duration-150 active:bg-yellow-500 text-lg">
          <span id="spinButtonText">SPIN THE WHEEL!</span>
        </button>
        <button id="removeAllEntriesBtn"
          class="w-full text-sm bg-gray-200 text-gray-700 p-2 rounded-lg hover:bg-gray-300 transition duration-150">Clear
          All Entries</button>
      </div>
    </div>

    <!-- 2. WHEEL Section -->
    <div id="wheelContainer"
      class="card p-6 flex flex-col items-center justify-center order-1 lg:order-2 col-span-1 lg:col-span-2 relative">
      <h2 class="text-xl font-bold mb-4 text-gray-800">RANDOM WINNER PICKER</h2>

      <!-- Pointer (Must be outside canvas but relative to container) -->
      <div
        class="pointer absolute top-1/2 right-[calc(50%-150px)] md:right-[calc(50%-200px)] lg:right-[calc(50%-250px)]"
        style="transform: translateY(-50%) rotate(90deg);"></div>

      <canvas id="wheelCanvas" width="500" height="500" class="max-w-full h-auto"></canvas>

      <!-- Result Modal (Hidden by default) -->
      <div id="resultModal"
        class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden p-4">
        <div class="bg-white p-8 rounded-xl shadow-2xl text-center max-w-md w-full">
          <h3 class="text-3xl font-extrabold text-green-600 mb-4">ðŸŽ‰ WE HAVE A WINNER! ðŸŽ‰</h3>
          <p class="text-5xl font-black text-gray-800 mb-6" id="winningName">NAME</p>
          <button id="closeModalBtn"
            class="bg-blue-600 text-white p-3 rounded-lg hover:bg-blue-700 transition duration-150 font-semibold">Spin
            Again / Close</button>
        </div>
      </div>

      <!-- Status Message -->
      <p id="statusMessage" class="mt-4 p-2 text-center text-sm text-red-600 font-medium hidden"></p>
    </div>
  </main>

  <script>
    // --- Global Variables and Constants ---
    const ENTRY_STORAGE_KEY = 'wheelEntries';
    let entries = [];
    let isSpinning = false;

    // --- Wheel Configuration ---
    const colorPalette = [
      '#ef4444', // Red
      '#3b82f6', // Blue
      '#10b981', // Green
      '#f59e0b', // Yellow
      '#8b5cf6', // Violet
      '#ec4899', // Pink
    ];

    // --- Canvas Variables ---
    const canvas = document.getElementById('wheelCanvas');
    const ctx = canvas.getContext('2d');
    let arc; // Size of each slice in radians
    let rotation = 0; // Current rotation of the wheel

    // --- DOM Elements ---
    const entryList = document.getElementById('entryList');
    const newEntryNameInput = document.getElementById('newEntryName');
    const addEntryBtn = document.getElementById('addEntryBtn');
    const removeAllEntriesBtn = document.getElementById('removeAllEntriesBtn');
    const spinWheelBtn = document.getElementById('spinWheelBtn');
    const spinButtonText = document.getElementById('spinButtonText');
    const resultModal = document.getElementById('resultModal');
    const winningNameDisplay = document.getElementById('winningName');
    const closeModalBtn = document.getElementById('closeModalBtn');
    const statusMessage = document.getElementById('statusMessage');
    const wheelContainer = document.getElementById('wheelContainer');


    // --- Utility Functions ---

    /** Displays a status message to the user. */
    const displayStatus = (message, isError = false) => {
      statusMessage.textContent = message;
      statusMessage.classList.remove('hidden', 'text-red-600', 'text-green-600');
      statusMessage.classList.add(isError ? 'text-red-600' : 'text-green-600');
      if (message) {
        statusMessage.classList.remove('hidden');
        // Only hide if it's not a critical error
        if (!isError) {
          setTimeout(() => { statusMessage.classList.add('hidden'); }, 4000);
        }
      } else {
        statusMessage.classList.add('hidden');
      }
    };

    /** Saves the current entries array to localStorage. */
    const saveEntries = () => {
      try {
        localStorage.setItem(ENTRY_STORAGE_KEY, JSON.stringify(entries));
      } catch (error) {
        console.error("Could not save to localStorage:", error);
        displayStatus("Error: Could not save entries. Storage is full or unavailable.", true);
      }
    };

    /** Loads entries from localStorage. */
    const loadEntries = () => {
      try {
        const storedEntries = localStorage.getItem(ENTRY_STORAGE_KEY);
        entries = storedEntries ? JSON.parse(storedEntries) : [];
        renderEntryList();
        drawWheel();
      } catch (error) {
        console.error("Could not load from localStorage:", error);
        displayStatus("Error: Could not load entries. Corrupt data or unavailable storage.", true);
      }
    };


    // --- Entry Management ---

    /** Renders the list of entries in the Inputs section. */
    const renderEntryList = () => {
      entryList.innerHTML = '';
      if (entries.length === 0) {
        entryList.innerHTML = '<p class="text-center text-gray-400 pt-4 text-sm">Add names or options above.</p>';
        // Disable spin button if less than 2 entries
        spinWheelBtn.disabled = true;
        spinWheelBtn.classList.replace('bg-yellow-400', 'bg-gray-300');
        spinButtonText.textContent = "Need at least 2 entries";
        return;
      }

      spinWheelBtn.disabled = false;
      spinWheelBtn.classList.replace('bg-gray-300', 'bg-yellow-400');
      spinButtonText.textContent = "SPIN THE WHEEL!";

      entries.forEach((entry, index) => {
        const entryItem = document.createElement('div');
        entryItem.id = `entry-${index}`;
        entryItem.className = 'flex items-center justify-between p-2 bg-white border rounded-lg shadow-sm';
        entryItem.innerHTML = `
                    <span class="text-sm font-medium text-gray-800">${index + 1}. ${entry.name}</span>
                    <button data-index="${index}" class="remove-entry-btn text-red-500 hover:text-red-700 p-1 transition duration-150 rounded-full" aria-label="Remove ${entry.name}">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 10-2 0v6a1 1 0 102 0V8z" clip-rule="evenodd" />
                        </svg>
                    </button>
                `;
        entryList.appendChild(entryItem);
      });
    };

    /** Adds a new entry from the input field. */
    const addEntry = () => {
      const name = newEntryNameInput.value.trim();
      if (name) {
        // Check for duplicates (case-insensitive)
        if (entries.some(e => e.name.toLowerCase() === name.toLowerCase())) {
          displayStatus("Entry name already exists!", true);
          return;
        }

        entries.push({ name: name });
        newEntryNameInput.value = '';
        renderEntryList();
        saveEntries();
        drawWheel();
        displayStatus(`'${name}' added.`);
      } else {
        displayStatus("Please enter a name or option.", true);
      }
    };

    /** Removes an entry by index. */
    const removeEntry = (index) => {
      if (index >= 0 && index < entries.length) {
        const name = entries[index].name;
        entries.splice(index, 1);
        renderEntryList();
        saveEntries();
        drawWheel();
        displayStatus(`'${name}' removed.`);
      }
    };

    /** Removes all entries. */
    const removeAllEntries = () => {
      if (entries.length > 0) {
        entries = [];
        renderEntryList();
        saveEntries();
        drawWheel();
        displayStatus("All entries cleared.");
      }
    };


    // --- Wheel Drawing and Logic ---

    /** Draws the wheel sections and text on the canvas. */
    const drawWheel = () => {
      const numEntries = entries.length;
      const size = Math.min(canvas.width, canvas.height);
      const centerX = size / 2;
      const centerY = size / 2;
      const radius = size * 0.4;

      // Clear the canvas
      ctx.clearRect(0, 0, size, size);

      if (numEntries === 0) {
        ctx.font = "24px Inter";
        ctx.fillStyle = "#4b5563";
        ctx.textAlign = "center";
        ctx.fillText("Add entries to start!", centerX, centerY);
        return;
      }

      arc = 2 * Math.PI / numEntries;

      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.rotate(rotation);

      for (let i = 0; i < numEntries; i++) {
        const startAngle = i * arc;
        const endAngle = (i + 1) * arc;
        const color = colorPalette[i % colorPalette.length];

        // 1. Draw the pie slice
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.arc(0, 0, radius, startAngle, endAngle);
        ctx.fillStyle = color;
        ctx.fill();

        // 2. Draw the text (name)
        ctx.save();
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 16px Inter';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';

        // Rotate to the center of the arc
        const textAngle = startAngle + arc / 2;
        ctx.rotate(textAngle);

        // Draw text slightly offset from the center
        const text = entries[i].name;
        ctx.fillText(text, radius * 0.9, 0, radius * 0.8);

        ctx.restore();
      }

      ctx.restore();

      // Draw the center circle (hub)
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius * 0.2, 0, 2 * Math.PI);
      ctx.fillStyle = 'white';
      ctx.fill();
      ctx.lineWidth = 4;
      ctx.strokeStyle = '#3b82f6';
      ctx.stroke();
    };

    /** Spins the wheel to a random segment. */
    const spinWheel = () => {
      if (isSpinning || entries.length < 2) return;
      isSpinning = true;
      spinWheelBtn.disabled = true;
      spinButtonText.textContent = "SPINNING...";
      displayStatus("");

      const numEntries = entries.length;

      // 1. Calculate the target segment index (0 to numEntries - 1)
      const winningIndex = Math.floor(Math.random() * numEntries);
      const winningEntry = entries[winningIndex].name;

      // 2. Calculate the rotation required to align the winning segment to the pointer (at 90 degrees/pi/2)

      // Current rotation in radians (normalized between 0 and 2*PI)
      const normalizedRotation = rotation % (2 * Math.PI);

      // Angle of the winning segment's center from the start (0)
      const targetSegmentCenterAngle = (winningIndex * arc) + (arc / 2);

      // Required angle offset from the current rotation to make the target center align with 90 degrees (Math.PI / 2)
      // Target angle (where segment center should land): 2 * PI - PI / 2 (or 3/2 * PI if wheel rotation is clock-wise)
      // Since our wheel rotation is counter-clockwise (positive rotation moves segments backwards)
      // we want the end of the spin to be: targetSegmentCenterAngle = PI / 2 (or 90 deg)

      // Total rotation needed is the difference between the target position (relative to 0 rotation) 
      // and the current normalized position, plus several full rotations for dramatic effect.

      // Angle correction to align winning segment to 90 degrees pointer location
      let rotationCorrection = (Math.PI / 2) - targetSegmentCenterAngle;

      // Normalize the correction so we spin the shortest distance
      if (rotationCorrection > Math.PI) rotationCorrection -= 2 * Math.PI;
      if (rotationCorrection < -Math.PI) rotationCorrection += 2 * Math.PI;

      // Add several full rotations (e.g., 6-10 full spins)
      const numFullSpins = 8;
      const totalSpinAngle = (numFullSpins * 2 * Math.PI) + rotationCorrection;

      // Use a duration for the spin (e.g., 5 seconds)
      const duration = 5000;
      const startTime = Date.now();

      const animateSpin = () => {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);

        // Use easing function (easeOutQuad) for deceleration
        const easedProgress = 1 - Math.pow(1 - progress, 3);

        // Calculate current rotation amount
        const currentAngle = totalSpinAngle * easedProgress;

        rotation += currentAngle;
        drawWheel();

        if (progress < 1) {
          // Continue animation
          requestAnimationFrame(animateSpin);
        } else {
          // Spin finished
          isSpinning = false;
          spinWheelBtn.disabled = false;
          spinButtonText.textContent = "SPIN THE WHEEL!";
          showResult(winningEntry);
          // Update the global rotation state precisely to the final position
          rotation = (rotation % (2 * Math.PI));
        }
      };

      // Reset rotation to ensure smooth start of animation (only change the visual rotation)
      rotation = 0;
      requestAnimationFrame(animateSpin);
    };

    /** Displays the winning result in a modal. */
    const showResult = (winningName) => {
      winningNameDisplay.textContent = winningName;
      resultModal.classList.remove('hidden');
    };

    /** Hides the result modal. */
    const hideResult = () => {
      resultModal.classList.add('hidden');
    };


    // --- Event Listeners and Initial Setup ---

    // Input Entry via button
    addEntryBtn.addEventListener('click', addEntry);

    // Input Entry via Enter key
    newEntryNameInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        addEntry();
      }
    });

    // Remove Entry Listener (delegated)
    entryList.addEventListener('click', (e) => {
      if (e.target.closest('.remove-entry-btn')) {
        const button = e.target.closest('.remove-entry-btn');
        const index = parseInt(button.getAttribute('data-index'));
        removeEntry(index);
      }
    });

    // Remove All Entries
    removeAllEntriesBtn.addEventListener('click', removeAllEntries);

    // Start Spin
    spinWheelBtn.addEventListener('click', spinWheel);

    // Close Modal
    closeModalBtn.addEventListener('click', hideResult);

    // Allow canvas click to spin
    canvas.addEventListener('click', spinWheel);

    // Initial Load and Setup
    window.onload = () => {
      // Resize canvas to be responsive but maintain square aspect ratio
      const resizeCanvas = () => {
        const containerSize = wheelContainer.clientWidth - 50; // Use container width minus padding
        const size = Math.min(containerSize, 500); // Max size 500px
        canvas.width = size;
        canvas.height = size;
        drawWheel(); // Redraw on resize
      };

      window.addEventListener('resize', resizeCanvas);

      loadEntries();
      resizeCanvas(); // Initial draw and sizing
    };
  </script>
</body>

</html>